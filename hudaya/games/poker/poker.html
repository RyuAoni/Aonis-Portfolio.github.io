<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ポーカー (Texas Hold'em)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { background: #35654d; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; text-align: center; margin: 0; min-height: 100vh; padding: 1rem; box-sizing: border-box; }
        .screen-container { display: flex; align-items: flex-start; justify-content: center; width: 100%; min-height: calc(100vh - 2rem); }

        #lobby-area { display: block; background-color: #1f2937; border: 4px solid #4f46e5; width: 90%; max-width: 60rem; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        #lobby-area h1 { color: #818cf8; font-size: 2.25rem; font-weight: bold; }
        #lobby-area h2 { color: #a5b4fc; font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem; }

        #game-board-area { display: none; background-color: #3e7b5b; border-radius: 20px; box-shadow: 0 0 40px rgba(0, 0, 0, 0.9), inset 0 0 20px rgba(0, 0, 0, 0.5); padding: 20px; border: 5px solid #a87e2b; width: 98%; max-width: 1000px; min-height: 85vh; display: flex; flex-direction: column; position: relative; box-sizing: border-box; }

        h1#game-title { color: #ffeb3b; text-transform: uppercase; letter-spacing: 3px; border-bottom: 3px solid #a87e2b; padding-bottom: 10px; margin-bottom: 15px; font-size: 1.8em; }
        #status-message { font-size: 1.2em; color: #ffeb3b; margin-bottom: 15px; font-weight: bold; min-height: 1.5em; }

        .community-cards-area { margin: 15px 0; padding: 10px; border-radius: 12px; border: 2px solid #a87e2b; background-color: rgba(0, 0, 0, 0.3); }
        .community-cards-area h2 { color: #ffd700; font-size: 1.2em; margin-bottom: 10px; }
        .cards { display: flex; justify-content: center; gap: 10px; min-height: 100px; flex-wrap: wrap; align-items: center; }
        .card { width: 65px; height: 95px; border-radius: 6px; box-shadow: 3px 3px 8px rgba(0,0,0,0.6); background-color: white; background-size: cover; background-position: center; border: 3px solid #fdd835; transition: transform 0.2s ease-in-out; }
        .card:hover { transform: translateY(-4px); }

        .pot-display { margin-top: 10px; font-size: 1.3em; font-weight: bold; color: #fdd835; }

        #players-area { display: flex; justify-content: space-around; flex-grow: 1; align-items: flex-start; flex-wrap: wrap; gap: 15px; margin-top: 20px; width: 100%; }
        .player-box { background: rgba(0,0,0,0.3); border: 2px solid rgba(168, 126, 43, 0.5); border-radius: 12px; padding: 10px; min-width: 180px; flex-basis: 22%; transition: all 0.3s ease; text-align: center; position: relative; }
        .player-box.is-turn { border-color: #ffeb3b; box-shadow: 0 0 15px #ffeb3b; }
        .player-box h3 { font-size: 1em; color: #ffeb3b; margin-bottom: 8px; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; justify-content: center; }
        .player-position { font-size: 0.7em; color: #ccc; background: #555; border-radius: 50%; width: 18px; height: 18px; line-height: 18px; text-align: center; margin-right: 5px; font-weight: bold; display: inline-block; }
        .player-box .hand { min-height: 100px; margin-bottom: 5px;}
        .player-box .points, .player-box .bet, .player-box .status { font-size: 0.8em; margin: 2px 0; color: #ccc; }
        .player-box .status-value { font-weight: bold; }
        .status-playing { color: #8bc34a; } .status-fold { color: #e57373; } .status-allin { color: #ffb74d; } .status-waiting { color: #90a4ae; } .status-showdown { color: #ce93d8; }

        #controls { width: 100%; display: flex; justify-content: center; align-items: center; padding: 15px 10px 0; margin-top: 15px; box-sizing: border-box; flex-wrap: wrap; }
        .action-controls { display: none; width: 100%; flex-wrap: wrap; justify-content: center; gap: 5px; }
        .action-row { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; width: 100%; margin-bottom: 5px; } /* ボタンを行でまとめる */
        .action-controls button, #next-round-btn { padding: 10px 18px; font-size: 14px; cursor: pointer; margin: 5px; border: none; border-radius: 8px; background-color: #fdd835; color: #212121; font-weight: bold; text-transform: uppercase; box-shadow: 0 4px #c5ae00; transition: all 0.15s ease-out; }
        .action-controls button:hover:not(:disabled), #next-round-btn:hover:not(:disabled) { background-color: #ffeb3b; transform: translateY(-2px); }
        .action-controls button:active, #next-round-btn:active { box-shadow: 0 2px #c5ae00; transform: translateY(2px); }
        .action-controls button:disabled, #next-round-btn:disabled { background-color: #555; color: #aaa; cursor: not-allowed; box-shadow: none; transform: none; }
        .bet-input-area { display: flex; align-items: center; margin: 5px; background-color: rgba(0,0,0,0.2); padding: 5px 10px; border-radius: 8px; }
        #bet-amount-input { /* スライダーから入力に変更 */
            padding: 6px 10px; font-size: 1rem; border-radius: 6px; border: 2px solid #a87e2b; background: #35654d; color: #ffeb3b; width: 100px; text-align: center; margin: 0 10px; font-weight: bold; -moz-appearance: textfield; appearance: textfield;
        }
        #bet-amount-input::-webkit-inner-spin-button, #bet-amount-input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        #raise-button { background-color: #ff9800; }
        #raise-button:hover:not(:disabled) { background-color: #ffb74d; }

        .modal-backdrop { background-color: rgba(0, 0, 0, 0.8); display: none; position: fixed; inset: 0; z-index: 50; align-items: center; justify-content: center; }
        .modal-content { background-color: #3e7b5b; border: 4px solid #a87e2b; color: #e0e0e0; padding: 2rem; border-radius: 1rem; text-align: center; max-width: 90%; width: 600px; box-shadow: 0 0 30px rgba(0,0,0,0.7); }
        .modal-content h2 { color: #ffeb3b; font-size: 1.8rem; margin-bottom: 1.5rem;}
        .modal-results p { margin: 8px 0; font-size: 1.1rem; }
        .winner { font-weight: bold; color: #8bc34a; }
        .split { color: #bdbdbd; }
    </style>
</head>
<body>
<div class="screen-container">

    <div id="lobby-area">
         <div class="text-center">
            <h1>ポーカー (Texas Hold'em)</h1>
            <p class="text-gray-400">ルームID: <span id="room-id-display" class="font-mono bg-gray-700 p-1 rounded"></span></p>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
            <div class="md:col-span-1 bg-gray-900 p-4 rounded-lg"><h2>参加者リスト</h2><ul id="player-list" class="space-y-2"></ul></div>
            <div id="gm-panel" class="md:col-span-2 bg-gray-900 p-4 rounded-lg" style="display: none;">
                <h2>ゲーム設定 (GM専用)</h2>
                <div class="space-y-4">
                    <p class="text-gray-400">プレイヤー: 2～4人 / 10ラウンド制 / 初期 1000pt</p>
                </div>
                <button id="start-game-btn" class="mt-6 w-full py-3 px-4 border border-transparent rounded-md shadow-sm text-lg font-medium text-white bg-indigo-600 hover:bg-indigo-700">ゲーム開始</button>
            </div>
            <div id="player-wait-message" class="md:col-span-2 flex items-center justify-center bg-gray-900 p-4 rounded-lg">
                <p class="text-gray-400 text-lg">参加者を待っています...</p>
            </div>
        </div>
    </div>


    <div id="game-board-area">
        <h1 id="game-title">Poker - Round <span id="round-number">1</span>/10 (<span id="phase-name"></span>)</h1>
        <div id="status-message"></div>

        <div class="community-cards-area" id="community-cards-area">
            <h2>コミュニティカード</h2>
            <div class="cards" id="community-cards"></div>
            <div class="pot-display">Pot: <span id="pot-amount">0</span></div>
        </div>

        <div id="players-area">
            </div>

        <div id="controls">
             <div class="action-controls" id="player-actions">
                 <div class="action-row">
                     <button id="fold-button">Fold</button>
                     <button id="check-button" style="display: none;">Check</button>
                     <button id="call-button" style="display: none;">Call <span id="call-amount">0</span></button>
                 </div>
                 <div class="action-row bet-input-area" id="raise-input-area">
                     <input type="number" id="bet-amount-input" min="20" max="1000" step="10" value="20">
                     <button id="raise-button">Raise <span>20</span></button> </div>
            </div>
             <button id="gm-next-hand-btn" style="display: none;">次のハンドへ</button>
        </div>
    </div>

     <div id="result-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2 id="result-title">ラウンド結果</h2>
            <div id="player-results" class="modal-results space-y-2">
                </div>
             <button id="close-result-btn" class="mt-6">閉じる</button>
        </div>
    </div>

</div>

    <script>
        // --- DOM Elements ---
        const lobbyArea = document.getElementById('lobby-area');
        const gameBoardArea = document.getElementById('game-board-area');
        const roomIdDisplay = document.getElementById('room-id-display');
        const playerList = document.getElementById('player-list');
        const gmPanel = document.getElementById('gm-panel');
        const playerWaitMessage = document.getElementById('player-wait-message');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameTitleEl = document.getElementById('game-title');
        const roundNumberEl = document.getElementById('round-number');
        const phaseNameEl = document.getElementById('phase-name');
        const statusMessageEl = document.getElementById('status-message');
        const communityCardsAreaEl = document.getElementById('community-cards-area');
        const communityCardsEl = document.getElementById('community-cards');
        const potAmountEl = document.getElementById('pot-amount');
        const playersAreaEl = document.getElementById('players-area');
        const controlsEl = document.getElementById('controls');
        const playerActionsEl = document.getElementById('player-actions');
        const foldBtn = document.getElementById('fold-button');
        const checkBtn = document.getElementById('check-button');
        const callBtn = document.getElementById('call-button');
        const callAmountSpan = document.getElementById('call-amount');
        const raiseInputArea = document.getElementById('raise-input-area');
        const betAmountInput = document.getElementById('bet-amount-input');
        const raiseBtn = document.getElementById('raise-button');
        const gmNextHandBtn = document.getElementById('gm-next-hand-btn'); // メイン画面のGMボタン
        const resultModal = document.getElementById('result-modal');
        const resultTitle = document.getElementById('result-title');
        const playerResultsEl = document.getElementById('player-results');
        const nextRoundBtnModal = document.getElementById('next-round-btn-modal');
        const closeResultBtn = document.getElementById('close-result-btn');

        // --- State ---
        let currentUser = null; let myRole = 'spectator'; let myPlayerId = null; let currentBoardState = null;
        const urlParams = new URLSearchParams(window.location.search); const roomId = urlParams.get('roomId');
        if (roomIdDisplay) roomIdDisplay.textContent = roomId; const socket = io();

        // --- Helper: カード画像パス ---
        function getCardImage(card, isFaceDown = false) {
             if (isFaceDown || !card || !card.suit || card.suit === 'back') { return "/images/cards/card-back.png"; }
             return `/images/cards/${card.suit}${card.value}.png`;
        }
        // --- Helper: カード要素作成 ---
        function renderCard(card, isFaceDown = false) {
            const img = document.createElement("img");
            img.src = getCardImage(card, isFaceDown);
            img.classList.add('card');
            img.alt = isFaceDown ? "Hidden" : `${card.value} of ${card.suit}`;
            return img;
        }

        // --- Socket.IO Event Listener: Board Update ---
        const handleBoardUpdate = ({ boardState, myHand, myRole: roleFromServer }) => {
            if (lobbyArea.style.display !== 'none') { lobbyArea.style.display = 'none'; gameBoardArea.style.display = 'flex'; }
            currentBoardState = boardState; myRole = roleFromServer; myPlayerId = currentUser ? currentUser.id : null;

            roundNumberEl.textContent = boardState.round; phaseNameEl.textContent = boardState.phase.toUpperCase();

            // --- GM/観戦者ビュー ---
            if (myRole !== 'player') {
                communityCardsAreaEl.style.display = 'block'; // コミュニティカード表示
                playersAreaEl.style.display = 'flex'; // プレイヤーエリア表示

                communityCardsEl.innerHTML = '';
                boardState.communityCards.forEach(card => communityCardsEl.appendChild(renderCard(card)));
                potAmountEl.textContent = boardState.pot.toLocaleString();

                playersAreaEl.innerHTML = '';
                boardState.players.forEach(pData => {
                    if (pData.status === 'out') return;
                    const playerBox = document.createElement('div'); playerBox.className = 'player-box'; playerBox.id = `player-box-${pData.id}`;
                    if (pData.isTurn) playerBox.classList.add('is-turn');
                    const isMe = pData.id === myPlayerId;
                    let positionMark = '';
                    if (pData.isDealer) positionMark = '<span class="player-position">D</span>';
                    if (pData.isSB) positionMark = '<span class="player-position">SB</span>';
                    if (pData.isBB) positionMark = '<span class="player-position">BB</span>';
                    playerBox.innerHTML = `<h3>${positionMark}${pData.nickname}${isMe ? ' (YOU)' : ''}</h3><div class="hand player-hand" id="player-hand-${pData.id}"></div><p class="points">Points: ${pData.points.toLocaleString()}</p><p class="bet">Bet (Hand): ${pData.currentBet > 0 ? pData.currentBet.toLocaleString() : '-'}</p><p class="status">Status: <span class="status-value status-${pData.status}">${pData.status.toUpperCase()}</span></p>`;
                    playersAreaEl.appendChild(playerBox);
                    const handEl = playerBox.querySelector(`#player-hand-${pData.id}`);
                    const showHands = ['showdown', 'roundEnd', 'gameOver'].includes(boardState.phase);
                    if (pData.hand && pData.hand.length > 0) {
                        pData.hand.forEach(card => handEl.appendChild(renderCard(card, !showHands))); // フェーズに応じて裏表
                    } else if (pData.status !== 'fold' && pData.status !== 'waiting') {
                         for (let i = 0; i < 2; i++) { handEl.appendChild(renderCard(null, true)); } // 通常は裏向き2枚
                    } else if (pData.status === 'fold') { handEl.innerHTML = `<span style="color: #e57373; font-weight: bold;">FOLDED</span>`; }
                });

            // --- プレイヤービュー ---
            } else {
                communityCardsAreaEl.style.display = 'none'; // コミュニティカード非表示
                playersAreaEl.style.display = 'flex'; // プレイヤーエリア表示 (自分のだけ)
                potAmountEl.textContent = boardState.pot.toLocaleString(); // ポットは表示

                playersAreaEl.innerHTML = ''; // クリア
                const myPlayerData = boardState.players.find(p => p.id === myPlayerId);

                if (myPlayerData && myPlayerData.status !== 'out') {
                    const playerBox = document.createElement('div');
                    playerBox.className = 'player-box w-full max-w-md mx-auto'; // 中央寄せ
                    playerBox.id = `player-box-${myPlayerData.id}`;
                    if (myPlayerData.isTurn) playerBox.classList.add('is-turn');
                    let positionMark = '';
                    if (myPlayerData.isDealer) positionMark = '<span class="player-position">D</span>';
                    if (myPlayerData.isSB) positionMark = '<span class="player-position">SB</span>';
                    if (myPlayerData.isBB) positionMark = '<span class="player-position">BB</span>';
                    playerBox.innerHTML = `<h3>${positionMark}${myPlayerData.nickname} (YOU)</h3><div class="hand player-hand" id="player-hand-${myPlayerData.id}"></div><p class="points">Points: ${myPlayerData.points.toLocaleString()}</p><p class="bet">Bet (Hand): ${myPlayerData.currentBet > 0 ? myPlayerData.currentBet.toLocaleString() : '-'}</p><p class="status">Status: <span class="status-value status-${myPlayerData.status}">${myPlayerData.status.toUpperCase()}</span></p>`;
                    playersAreaEl.appendChild(playerBox);
                    const handEl = playerBox.querySelector(`#player-hand-${myPlayerData.id}`);
                    myHand.forEach(card => handEl.appendChild(renderCard(card))); // 自分の手札表示
                }
            }

            // コントロール表示切り替え
            const myPlayerDataForControl = boardState.players.find(p => p.id === myPlayerId);
            const isMyTurn = myRole === 'player' && myPlayerDataForControl?.isTurn && myPlayerDataForControl?.status === 'playing';
            const showGmNextButton = myRole === 'gm' && boardState.phase === 'roundEnd'; // GM かつ ラウンド終了時
            playerActionsEl.style.display = isMyTurn ? 'flex' : 'none';
            gmNextHandBtn.style.display = showGmNextButton ? 'inline-block' : 'none';

            if (isMyTurn) { updateActionButtons(myPlayerDataForControl, boardState.currentMaxBet); }

            // メッセージ表示
            const latestLog = boardState.log[boardState.log.length - 1];
            if (latestLog) statusMessageEl.textContent = latestLog;

        };

        // --- Update Action Buttons Logic ---
        function updateActionButtons(playerData, currentMaxBet) {
             if (!playerData) return;
             const callAmount = currentMaxBet - playerData.actionAmount;
             const canCheck = callAmount <= 0;
             const canCall = callAmount > 0 && playerData.points > 0;
             const canRaiseBet = playerData.points > callAmount;

             checkBtn.style.display = canCheck ? 'inline-block' : 'none';
             callBtn.style.display = canCall ? 'inline-block' : 'none';
             callAmountSpan.textContent = Math.min(callAmount, playerData.points).toLocaleString();

             raiseInputArea.style.display = canRaiseBet ? 'flex' : 'none';
             if (canRaiseBet) {
                 const minRaiseToAdd = currentBoardState ? Math.max(BIG_BLIND, currentBoardState.lastRaiseAmount || BIG_BLIND) : BIG_BLIND;
                 const minTotalBetForPhase = currentMaxBet + minRaiseToAdd;
                 const minBetValue = minTotalBetForPhase - playerData.actionAmount;
                 const allInAmount = playerData.points + playerData.actionAmount; // Total amount if all-in this phase
                 const allInAmountToAdd = playerData.points; // Amount to add for all-in

                 const effectiveMinAdd = Math.max(1, Math.min(minBetValue, allInAmountToAdd)); // Min amount to add

                 // Minimum amount to ADD must be at least minRaiseToAdd, unless going all-in for less
                 betAmountInput.min = effectiveMinAdd;
                 betAmountInput.max = allInAmountToAdd;
                 betAmountInput.step = 10; // または BIG_BLIND など適切な値
                 // 初期値は最低レイズ額かAllin額の小さい方
                 betAmountInput.value = effectiveMinAdd;

                 raiseBtn.textContent = (currentMaxBet === 0 ? 'Bet' : 'Raise') + ` ${betAmountInput.value.toLocaleString()}`;
             }
             foldBtn.disabled = !(playerData.status === 'playing');
        }

        // ★ 追加: Inputのイベントリスナー (Raiseボタンのテキスト更新用)
        betAmountInput.oninput = () => {
             const amount = parseInt(betAmountInput.value);
             const isBetAction = (currentBoardState?.currentMaxBet || 0) === 0;
             // 入力が不正な場合はボタンテキストを更新しない
             if (!isNaN(amount) && amount >= parseInt(betAmountInput.min) && amount <= parseInt(betAmountInput.max)) {
                 raiseBtn.textContent = (isBetAction ? 'Bet' : 'Raise') + ` ${amount.toLocaleString()}`;
             } else {
                  raiseBtn.textContent = (isBetAction ? 'Bet' : 'Raise') + ` ?`; // 不正値の場合
             }
        };

        // --- Document Ready ---
        document.addEventListener('DOMContentLoaded', () => {
            lobbyArea.style.display = 'block'; gameBoardArea.style.display = 'none'; resultModal.style.display = 'none';
            if (!socket) return alert("接続エラー");
            const token = localStorage.getItem('token');
            if (!token || !roomId) return window.location.href = '/home.html';
            try {
                currentUser = JSON.parse(atob(token.split('.')[1]));
                myRole = currentUser.role === 'owner' ? 'gm' : 'player'; myPlayerId = currentUser.id;
                if (myRole === 'gm') { gmPanel.style.display = 'block'; playerWaitMessage.style.display = 'none'; }
                else { gmPanel.style.display = 'none'; playerWaitMessage.style.display = 'flex'; }
            } catch (e) { localStorage.removeItem('token'); return window.location.href = '/login.html'; }
            socket.emit('joinLobby', { token, roomId });
        });

        // --- Socket.IO Event Listeners ---
        if (socket) {
            socket.on('gameStarted', handleBoardUpdate);
            socket.on('updateBoard', handleBoardUpdate);
            socket.on('updateLobby', ({ participants }) => {
                 if (!playerList || !gmPanel || !playerWaitMessage) { console.error("Lobby elements not found!"); return; }
                 playerList.innerHTML = ''; let isGmInLobby = false;
                 participants.forEach(p => {
                     const li = document.createElement('li'); li.className = 'flex items-center justify-between p-2 bg-gray-700 rounded';
                     const nicknameSpan = document.createElement('span'); nicknameSpan.textContent = p.nickname || `Player ${p.id}`;
                     if (currentUser && p.id === currentUser.id) { nicknameSpan.className = "font-bold text-indigo-400"; myRole = p.role; if (p.role === 'gm') isGmInLobby = true; }
                     const roleSpan = document.createElement('span'); let roleText = 'Spectator'; let roleClass = 'bg-gray-500';
                     if (p.role === 'gm') { roleText = 'GM'; roleClass = 'bg-yellow-500 text-gray-900 font-bold'; } else if (p.role === 'player') { roleText = 'Player'; roleClass = 'bg-blue-500'; }
                     roleSpan.textContent = roleText; roleSpan.className = `text-xs ${roleClass} px-2 py-1 rounded-full`;
                     li.appendChild(nicknameSpan); li.appendChild(roleSpan); playerList.appendChild(li);
                 });
                 if (isGmInLobby) {
                     gmPanel.style.display = 'block'; playerWaitMessage.style.display = 'none';
                     const playerCount = participants.filter(p => p.role === 'player').length;
                     startGameBtn.disabled = playerCount < 2 || playerCount > 4;
                     startGameBtn.textContent = startGameBtn.disabled ? `ゲーム開始 (${playerCount}/2-4人)` : 'ゲーム開始';
                 } else { gmPanel.style.display = 'none'; playerWaitMessage.style.display = 'flex'; }
            });
            socket.on('promptAction', ({ playerId, options, minRaise, callAmount, maxBet }) => {
                 if (myPlayerId === playerId) { statusMessageEl.textContent = "あなたの番です。アクションを選択してください。"; }
                 else { const currentPlayerNickname = currentBoardState?.players.find(p=>p.id === playerId)?.nickname || 'プレイヤー'; statusMessageEl.textContent = `${currentPlayerNickname} のアクション待ち...`; }
            });
             socket.on('gameLog', (message) => { statusMessageEl.textContent = message; });
            socket.on('roundResult', ({ winnerNicknames, potAmount, handName, communityCards, playersData, isFinalRound, gmId }) => {
                 resultTitle.textContent = `ラウンド ${currentBoardState?.round} 結果`;
                 // コミュニティカード表示削除
                 playerResultsEl.innerHTML = ''; let winnerMessage = '';
                 if (winnerNicknames.length > 1) { winnerMessage = `${winnerNicknames.join(' と ')} のスプリットポット！`; playerResultsEl.innerHTML += `<p class="split">${winnerMessage}</p>`; }
                 else if (winnerNicknames.length === 1) { winnerMessage = `${winnerNicknames[0]} の勝利！`; playerResultsEl.innerHTML += `<p class="winner">${winnerMessage}</p>`; }
                 else { winnerMessage = "勝者なし"; }
                 if(handName) playerResultsEl.innerHTML += `<p>役: ${handName}</p>`;
                 playerResultsEl.innerHTML += `<p>ポット: ${potAmount.toLocaleString()}</p><hr class="my-2 border-gray-500">`;
                 playersData.forEach(p => {
                      const handRank = p.handRank ? `(${p.handRank.name})` : '';
                      const prevPoints = currentBoardState?.players.find(prev=>prev.id === p.id)?.points ?? p.points;
                      const pointChange = p.points - prevPoints;
                      const pointChangeText = pointChange > 0 ? `+${pointChange.toLocaleString()}` : pointChange < 0 ? `${pointChange.toLocaleString()}` : '';
                      // 手札表示削除
                      playerResultsEl.innerHTML += `<p>${p.nickname}: ${p.points.toLocaleString()} pts ${pointChangeText} ${handRank}</p>`;
                 });
                 const isGM = myRole === 'gm';
                 // ★ 修正: モーダル内のGMボタンは削除したので制御不要
                 // nextRoundBtnModal.style.display = isGM ? 'inline-block' : 'none';
                 closeResultBtn.style.display = 'inline-block'; // 閉じるは常に表示
                 // ★ 修正: テキスト設定も不要
                 // nextRoundBtnModal.textContent = isFinalRound ? '最終結果へ' : '次のハンドへ';

                 resultModal.style.display = 'flex';
            });
            socket.on('gameOver', ({ results }) => { localStorage.setItem('gameResults', JSON.stringify(results.map(r => ({...r, score: r.score })))); window.location.href = window.location.origin + '/result.html'; });
            socket.on('error', (message) => { console.error('Socket Error:', message); statusMessageEl.textContent = `エラー: ${message}`; });
        }

        // --- UI Event Listeners ---
         if (startGameBtn) startGameBtn.addEventListener('click', () => { if (!socket || startGameBtn.disabled) return; socket.emit('startGame', { roomId, settings: {}, gameType: 'poker' }); });
         foldBtn.onclick = () => socket.emit('pokerAction', { roomId, action: 'fold' });
         checkBtn.onclick = () => socket.emit('pokerAction', { roomId, action: 'check' });
         callBtn.onclick = () => { const callAmountNeeded = currentBoardState.currentMaxBet - currentBoardState.players.find(p => p.id === myPlayerId)?.actionAmount; const actualCallAmount = Math.min(callAmountNeeded, currentBoardState.players.find(p => p.id === myPlayerId)?.points); socket.emit('pokerAction', { roomId, action: 'call', amount: actualCallAmount }); };
         raiseBtn.onclick = () => {
             const amount = parseInt(betAmountInput.value);
             // 簡単なクライアント側バリデーション
             const minVal = parseInt(betAmountInput.min);
             const maxVal = parseInt(betAmountInput.max);
             if (isNaN(amount) || amount < minVal || amount > maxVal) {
                 alert(`ベット額は ${minVal.toLocaleString()} から ${maxVal.toLocaleString()} の間で入力してください。`);
                 return;
             }
             const isBetAction = (currentBoardState?.currentMaxBet || 0) === 0;
             socket.emit('pokerAction', { roomId, action: (isBetAction ? 'bet' : 'raise'), amount: amount });
         };
         if (closeResultBtn) closeResultBtn.addEventListener('click', () => { resultModal.style.display = 'none'; });
         // ★ 修正: メイン画面のGMボタンのリスナーに変更
         if (gmNextHandBtn) gmNextHandBtn.addEventListener('click', () => { if (!socket) return alert('接続エラー'); socket.emit('nextRound', { roomId }); gmNextHandBtn.style.display = 'none'; }); // 押したら隠す

    </script>
</body>
</html>